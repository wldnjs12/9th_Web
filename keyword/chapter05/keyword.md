- 서버에서 HTML 문서를 응답할 때 CSP를 적용하려면 어떤 HTTP 응답 헤더를 설정해야 하나요? 블로그에 나온 Express.js 코드 예시를 기반으로 설명해보세요.
    
    서버에서 HTML 문서를 응답할 때 다음과 같은 **HTTP 응답 헤더**를 설정합니다:
    
    ```jsx
    res.setHeader('Content-Security-Policy', "default-src 'self'");
    ```
    
    👉 브라우저는 이 헤더를 보고, 지정된 정책에 따라 외부 리소스를 제한합니다.
    
- `default-src 'self'` 설정은 브라우저에게 어떤 보안 정책을 의미하나요? 또한 `'self'` 값은 어떤 출처를 포함하거나 제외하나요?
    - **`default-src`**: 모든 리소스의 기본 허용 범위를 지정합니다.
    - **`'self'`**: 현재 페이지와 같은 출처(origin) 에서만 자원을 불러올 수 있다는 뜻입니다.
        
        → 즉, 같은 도메인·프로토콜·포트는 허용되지만, 다른 도메인(예: CDN, 외부 서버)은 차단됩니다.
        
- 블로그에 나온 악성 스크립트(`<script>fetch(...)</script>`)를 주입했을 때 CSP가 어떻게 동작하는지 네트워크 탭과 콘솔 메시지 측면에서 설명해보세요.
    - `<script>fetch(...)</script>` 같은 외부 요청이 실행되지 않습니다.
    - 네트워크 탭: hacker.com으로의 요청이 보이지 않음
    - 콘솔 메시지: “CSP 위반으로 인해 인라인 스크립트를 차단했습니다” 라는 경고 표시
- 기본 CSP 설정에서 인라인 스타일이 차단된다고 했습니다. 블로그 예시 중 `width:600px`이 적용되지 않는 이유를 설명하세요.
    
    기본 설정(`default-src 'self'`)에서는 스타일 관련 정책(style-src) 이 별도로 없기 때문에,
    
    인라인 스타일(`width:600px`)도 보안상 위험한 인라인 코드로 간주되어 차단됩니다.
    
- 구글 애널리틱스, 카카오맵, 외부 API 등이 CSP 때문에 차단될 수 있다고 했습니다. 이러한 현상을 "건물 보안을 강화한다"는 비유와 연결해 설명해보세요.
    
    구글 애널리틱스, 카카오맵, 외부 API 등을 불러오려 하면 CSP가 막습니다.
    
    → 마치 건물 보안을 강화하려고 모든 문을 잠가버린 상황처럼,
    
    직원(정상 리소스)도 출입하지 못하는 문제가 생길 수 있습니다.
    
- Report-Only 모드에서는 실제 리소스 실행이 차단되지 않습니다. 그 대신 브라우저와 서버에서 각각 어떤 동작을 수행하나요?
    - 브라우저: 정책 위반을 진단만 하고 실행은 허용
    - 서버: `/report` 경로로 위반 보고서(JSON) 를 받음
        
        → 서비스는 정상 동작하지만, 위반 로그로 보안 위험을 모니터링할 수 있습니다.
        
    
    ---
    
- CSP만으로는 CSRF를 막을 수 없다고 했습니다. 블로그에 정리된 다른 보안 조치들(SameSite 쿠키, X-Frame-Options 등) 중 2가지를 설명하세요.
    1. SameSite 쿠키 속성:
        
        다른 사이트에서 요청이 오더라도 쿠키를 자동으로 전송하지 않아 CSRF 공격 방어.
        
    2. X-Frame-Options:
        
        다른 사이트가 내 웹페이지를 `<iframe>`으로 불러오지 못하게 하여 클릭재킹 방지.

        - 출처(Origin)는 어떤 세 요소의 조합으로 결정되나요?
    
    출처(origin)는 프로토콜 + 호스트(도메인) + 포트 세 가지의 조합으로 결정됩니다.
    
    예: `https://example.com:443` 은 프로토콜 `https`, 호스트 `example.com`, 포트 `443`.
    
- 출처의 요소가 다른 경우(예: 프로토콜만, 포트만 다른 경우)에 같은 출처인지 아닌지를 예시 3개(같은 출처 1개, 다른 출처 2개)로 설명하세요.
    - 같은 출처 (예)
        - 페이지: `https://www.example.com:443/page`
        - 리소스: `https://www.example.com:443/api/data`
        - → 같은 출처: 프로토콜 `https`, 호스트 `www.example.com`, 포트 `443` 모두 일치
    - 다른 출처 (예 1 — 프로토콜만 다른 경우)
        - 페이지: `http://www.example.com`
        - 리소스: `https://www.example.com`
        - → 다른 출처: 프로토콜(`http` vs `https`)이 다르므로 다른 출처로 간주
    - 다른 출처 (예 2 — 서브도메인/호스트 다른 경우)
        - 페이지: `https://example.com`
        - 리소스: `https://api.example.com`
        - → 다른 출처: 호스트가 `example.com` vs `api.example.com`으로 다름 → 다른 출처
- 블로그에 나온 `fetch` 기반 악성 스크립트를 다른 출처로 실행했을 때 브라우저에서 어떤 일이 발생하나요? 네트워크 전송 여부, 응답 사용 가능성, 브라우저 콘솔 메시지 측면에서 서술하세요.
    - 네트워크 전송 여부
        - 일반적으로 브라우저는 외부(다른 출처)로 요청을 보낼 수 있음. 즉 네트워크 탭에는 요청이 보일 수 있습니다. (단, CORS 프리플라이트가 필요한 경우 `OPTIONS` 프리플라이트가 먼저 발생할 수 있음.)
    - 응답 사용 가능성
        - 원칙적으로 응답의 본문을 자바스크립트가 읽을 수 없음. 서버가 적절한 CORS 응답 헤더(`Access-Control-Allow-Origin`)를 보내지 않으면 `fetch`/XHR로 가져온 응답의 데이터에 접근할 수 없습니다.
    - 브라우저 콘솔 메시지
        - 브라우저 콘솔에 `Cross-Origin Request Blocked` 또는 `동일 출처 정책으로 인해 ... 차단했습니다` 같은 에러/경고가 출력됩니다. (정확한 문구는 브라우저별 약간 다름.)
- SOP가 어떻게 Session Hijacking(세션 하이재킹) 시도를 방지하는지 구체적으로 설명하세요. SOP가 차단하는 것과 허용되는 것(예: 네트워크 요청은 나가지만 응답 데이터에 접근 불가)을 포함하세요.
    - 무엇을 막나:
        - SOP는 다른 출처의 페이지가 현재 페이지의 민감한 데이터(예: DOM, 쿠키 내용, AJAX 응답 등)를 직접 읽는 것을 차단합니다. 공격자가 자기 사이트에서 사용자의 로그인한 사이트(다른 출처)에 대해 XHR/fetch를 실행해 응답(예: 계좌정보, 인증 토큰)을 읽어오지 못하게 합니다.
    - 무엇을 허용하나:
        - 다른 출처로의 네트워크 요청 자체는 발생할 수 있음(예: `<img>` 로 요청, 혹은 일부 `fetch` 요청). 하지만 요청을 보낸 쪽(공격자)은 그 응답을 읽을 수 없습니다. 즉 요청은 나가지만 응답 데이터에 접근 불가 — 이 때문에 단순한 요청으로 세션값을 탈취해 읽어가는 공격은 실패합니다.
    - 한계와 보완 필요성:
        - SOP만으로 쿠키가 전혀 전송되지 않는 것은 아님. 브라우저는 도메인 규칙(쿠키 도메인/Path, SameSite, Secure 등)에 따라 쿠키를 전송할 수 있으므로(특정 상황에서), SOP와 함께 SameSite, HttpOnly, Secure 등의 쿠키 설정을 함께 사용해야 세션 보호가 더 튼튼해집니다.
    - 요약:
        - SOP는 다른 출처가 로그인 세션의 응답/데이터를 읽어 못 하게 막아 세션 탈취 시도 일부를 방어하지만, 쿠키 전송 행태는 별개의 설정(SameSite 등)에 의존하므로 다층 방어가 필요합니다.
- 블로그에서 명시한 대로 SOP가 반드시 동일 출처에서만 접근하도록 하는 주요 브라우저 API/리소스 3가지를 쓰고, 각각에 대해 간단한 설명(왜 제한되는지)을 덧붙이세요.
    - `fetch()` / `XMLHttpRequest` (AJAX)
        - 이유: 원격 응답에 포함된 민감 데이터(예: JSON 응답)를 다른 출처가 읽으면 정보 유출 가능 → SOP로 접근 차단
    - DOM 접근(iframe 내 다른 출처 문서의 DOM)
        - 이유: 한 페이지가 iframe으로 다른 출처를 임베드하더라도 내부 문서의 DOM을 조작/읽을 수 있으면 사용자 데이터나 세션 탈취 가능 → 직접 접근 금지
    - `@font-face`(교차 출처 웹폰트) / 일부 브라우저에서의 폰트 로딩 제약
        - 이유: 리소스가 페이로드(또는 정보 포함)로 악용될 수 있고, 폰트 파일의 출처·응답 헤더에 따라 브라우저가 차단하여 보안 위험을 줄임
- SOP와 CSP의 차이를 블로그 내용에 따라 요점 4개(각 항목 1문장)로 정리하세요. (예: 누가 적용하는가, 제어 주체, 설정 가능 여부 등)
    1. 누가 적용하나: SOP는 브라우저가 기본적으로 자동 적용하는 정책이고, CSP는 서버(개발자)가 HTTP 헤더로 브라우저에 지시하는 정책입니다.
    2. 제어 주체: SOP는 브라우저 내부 규칙(개발자가 직접 변경 불가), CSP는 개발자가 명시적으로 설정·조정할 수 있습니다.
    3. 목표/범위: SOP는 출처 기반 접근 제어(브라우저 API 접근 차단)가 목적이고, CSP는 스크립트·스타일·리소스의 허용 출처를 세밀히 통제하여 XSS를 방지하는 목적입니다.
    4. 유연성: SOP는 고정적(브라우저 구현에 따름)이고, CSP는 정책을 단계적으로 적용(Report-Only 등)하거나 리소스별로 상세하게 허용/차단할 수 있어 유연합니다.
- 브라우저에서 SOP 관련 차단 오류를 발견했을 때(예: 콘솔에 “동일 출처 정책으로 인해 ... 차단했습니다” 메시지) 문제 원인 파악을 위한 체크리스트(최소 3항목)를 작성하고, 임시·영구 대응 방안(각 1~2줄)도 제시하세요.
    1. 요청의 출처(origin)와 대상의 출처(origin)를 비교 — 프로토콜/호스트/포트가 모두 일치하는가?
    2. 서버 응답 헤더에 CORS 관련 헤더가 있는가? (`Access-Control-Allow-Origin`, `Access-Control-Allow-Credentials`, `Access-Control-Allow-Methods` 등)
    3. 브라우저 콘솔의 오류 메시지와 네트워크 탭의 요청/응답 헤더 확인 — 프리플라이트(OPTIONS) 실패인지, 단순 요청 차단인지 파악
    4. (추가) 요청에 credentials(쿠키/인증정보)을 포함하려면 `fetch` 쪽 `credentials` 설정과 서버의 `Access-Control-Allow-Credentials:true`가 일치하는지 확인
    
    임시 대응 방안
    
    - 프록시 사용 (개발/테스트용): 같은 출처로 보이게 하기 위해 개발 서버에서 API를 프록시 처리해 우회(빠른 검증용, 보안 주의).
    - 브라우저 플러그인/로컬 설정 사용 (개발 중): CORS 비활성 플러그인으로 우회(절대 운영 환경에선 사용 금지).
    
    영구 대응 방안
    
    - 서버에 적절한 CORS 헤더를 설정: `Access-Control-Allow-Origin`을 신뢰할 도메인으로 설정하고, 쿠키를 보낼 경우 `Access-Control-Allow-Credentials:true`와 함께 도메인을 정확히 지정.
    - 안전한 통합 방식 검토: iframe + `postMessage`(교차 창 통신)처럼 명시적 메시지 교환이나, 백엔드에서 서버-서버 통신으로 처리해 브라우저 SOP 제약을 우회하지 않고 안전하게 구현.

    - 브라우저에서 `http://localhost:8080` 애플리케이션이 `http://localhost:8081/resource.json`을 요청했을 때, 네트워크 요청과 응답은 어떻게 처리되며, 브라우저가 응답 본문을 사용하지 못하는 이유는 무엇인가요?
    - 네트워크 요청: 브라우저는 실제로 8081 서버로 HTTP 요청을 전송합니다.
    - 응답: 8081 서버가 응답을 보내지만, CORS 허용 헤더(`Access-Control-Allow-Origin`)가 없기 때문에
        
        브라우저는 응답 본문을 스크립트에서 읽을 수 없도록 차단합니다.
        
    - 결과:
        - 네트워크 탭 → 요청/응답은 존재함
        - 콘솔 → “교차 출처 요청 차단” 경고
        - 코드 내 → `response.text()` 등으로 본문 접근 불가
- 서버가 다른 출처(`http://localhost:8080`)에서 자원을 사용할 수 있게 하려면 어떤 응답 헤더를 어떻게 설정해야 하나요? 글의 예시 코드를 참고해 헤더 이름과 값까지 구체적으로 쓰세요.
    
    다음과 같이 응답 헤더를 추가해야 합니다
    
    ```jsx
    res.setHeader('Access-Control-Allow-Origin', 'http://localhost:8080');
    
    ```
    
    - 헤더 이름: `Access-Control-Allow-Origin`
    - 값: 허용할 출처(예: `http://localhost:8080`)
    - 의미: “8080 출처의 애플리케이션이 내 리소스를 사용할 수 있다”고 명시하는 것
    
    > 서버 코드 예시:
    > 
    > 
    > ```jsx
    > res.setHeader('Access-Control-Allow-Origin', 'http://localhost:8080');
    > static(path.join(__dirname, 'public'))(req, res);
    > 
    > ```
    > 
- 단순 요청으로 분류되기 위해서는 어떤 두 가지 조건을 만족해야 하나요? 또한 `GET /resource.json` 요청이 단순 요청에 해당하는 이유를 설명하세요.
    
    1️⃣ 허용된 HTTP 메소드 사용: `GET`, `POST`, `HEAD`
    
    2️⃣ 안전한 요청 헤더만 포함:
    
    `Accept`, `Accept-Language`, `Content-Language`, `Content-Type`, `Range` 등
    
    `GET /resource.json` 요청은
    
    - 메소드가 `GET` → 허용됨
    - 특별한 커스텀 헤더 없음 → 안전한 헤더만 포함
        
        따라서 단순 요청(Simple Request) 에 해당합니다.
        
    
    ---
    
- 브라우저에서 `X-Goguma`라는 커스텀 헤더를 추가했을 때 왜 차단이 발생하나요? 이 문제를 해결하기 위해 서버에서 추가해야 하는 응답 헤더와 값은 무엇인가요?
    - 차단 이유:
        
        브라우저가 허용 목록에 없는 헤더(`X-Goguma`)를 보냈기 때문입니다.
        
        → 서버가 이 헤더를 CORS 허용 목록에 명시하지 않았기 때문에 차단됨
        
    - 해결 방법 (응답 헤더 추가):
        
        ```jsx
        res.setHeader('Access-Control-Allow-Headers', 'X-Goguma');
        
        ```
        
        ➕ 기존의 `Access-Control-Allow-Origin` 헤더와 함께 설정해야 함:
        
        ```jsx
        res.setHeader('Access-Control-Allow-Origin', 'http://localhost:8080');
        res.setHeader('Access-Control-Allow-Headers', 'X-Goguma');
        
        ```
        
- `PUT` 요청을 보낼 때 브라우저는 왜 먼저 `OPTIONS` 요청을 보내나요? 이때 브라우저가 보내는 헤더와 서버가 응답해야 하는 헤더를 각각 쓰고, 사전 요청과 실제 요청이 어떻게 이어지는지 간단히 서술하세요.
    - 이유:
        
        `PUT`, `PATCH`, `DELETE` 등은 단순 요청이 아니므로
        
        브라우저가 먼저 “서버가 이 메소드를 허용하는지” 확인하기 위해 사전 요청(`OPTIONS`)을 보냅니다.
        
    - 브라우저가 보내는 헤더 예시:
        
        ```
        OPTIONS /resource.json
        Access-Control-Request-Method: PUT
        Access-Control-Request-Headers: X-Goguma
        Origin: http://localhost:8080
        
        ```
        
    - 서버가 응답해야 하는 헤더:
        
        ```jsx
        res.setHeader('Access-Control-Allow-Origin', 'http://localhost:8080');
        res.setHeader('Access-Control-Allow-Methods', 'PUT');
        res.setHeader('Access-Control-Allow-Headers', 'X-Goguma');
        
        ```
        
    - 흐름 요약:
        1. 브라우저 → `OPTIONS` 요청
        2. 서버 → `Access-Control-Allow-Methods: PUT` 응답
        3. 브라우저 → 실제 `PUT` 요청 전송
        4. 서버 → `PUT` 응답 전송, 브라우저가 정상적으로 본문 사용 가능

        - RBAC의 한계에 대해 설명해주세요.
    - 역할(Role) 단위로만 권한을 제어하기 때문에
        
        세부 조건이나 예외 케이스를 표현하기 어렵다.
        
    - 권한 로직이 UI와 서버 곳곳에 중복되고 흩어져 일관성 관리가 어렵다.
- ABAC으로의 전환, 어떤 '기준'이 적절할까요?
    - 단순 역할 구분만으로는 권한을 설명하기 힘들 때
    - 같은 역할이라도 사용자, 리소스, 상황 속성(Attribute) 에 따라 권한이 달라질 때
    - 서비스가 커지면서 조건 기반 정책이 필요할 때
- 어떤 서비스 영역에 RBAC을 남겨두고, ABAC을 도입하시겠어요?
    - RBAC 유지:
        - 전사 공통, 단순한 전역 권한
        - 시스템 전반의 기본 접근 제어
    - ABAC 도입:
        - 학원별·리소스별 세부 권한이 필요한 영역
        - 유연한 조건이 필요한 도메인
- 여러분들은 다른 부서에서 요청을 받았을 때 어떤식으로 행동하실껀가요?
    - 요청을 바로 코드에 반영하기보다
        
        권한 정책 테이블에서 해결 가능한지 먼저 검토한다.
        
    - 반복되는 예외 요청이 많다면 → 새로운 속성으로 관리하도록 설계한다.
    - 즉, “한 번의 수동 수정”이 아닌 “정책 구조로 해결”하는 방향으로 대응한다.
    - 필요 시 PM·백엔드와 협의해 데이터 스키마확장 후
        
        정책 테이블만 업데이트하는 방식으로 처리한다
        
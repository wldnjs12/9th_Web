# 어떤 상황에서 **낙관적 업데이트(OptimisticUpdate)가 효율적일까요? 🍠**

---

> **낙관적 업데이트(OptimisticUpdate)가 효율적인 상황은 언제일까요? 🍠**
> 

<aside>
📌

낙관적 업데이트는 사용자가 버튼을 누르자마자 화면이 먼저 바뀌는 방식으로, 서버 응답을 기다리지 않아도 즉각적인 반응을 보여줄 수 있다. 성공 확률이 높은 단순한 요청(예: 좋아요, 팔로우, 댓글 작성 등)에서 효과적이며, 네트워크가 느린 환경에서도 앱이 빠르게 느껴진다.

</aside>

> **낙관적 업데이트(OptimisticUpdate)를 피해야 하는 상황 언제일까요? 🍠**
> 

<aside>
📌

반면 결제, 인증, 송금처럼 실패 시 문제가 되는 작업에는 적용하면 안 된다. 데이터 불일치나 롤백의 복잡성 때문에 위험할 수 있고, 여러 사용자가 동시에 수정하는 협업 환경에서도 충돌이 생길 수 있다. 따라서 낙관적 업데이트는 **성공이 거의 확실한 간단한 요청에만 제한적으로 사용하는 것이 적절하다.**

</aside>

- **낙관적 업데이트(OptimisticUpdate) 블로그 읽고 개념 정리하기 🍠**
    
    # **낙관적 업데이트(OptimisticUpdate) 블로그 읽고 개념 정리하기 🍠**
    
    ---
    
    [개발자 매튜 | 실제 서비스에서 낙관적 업데이트(Optimistic Update)를 활용하여, 유저의 답답함 줄이기](https://www.yolog.co.kr/post/optimistic-update)
    
    - **낙관적 업데이트(OptimisticUpdate)**를 왜 도입해야 하는지, 이 패턴이 해결하려는 문제를 실제 서비스 맥락에서 설명해보세요.
        
        낙관적 업데이트는 서버 요청 완료를 기다리지 않고 UI를 먼저 갱신함으로써, 사용자가 느끼는 반응 속도를 극적으로 높여주는 기법이다.
        
        실제 서비스에서 네트워크 지연이나 서버 응답 시간이 길어질 경우, 사용자는 “버튼이 안 눌린다”, **“앱이 느리다”**는 불만을 가지게 된다.
        
        이때 낙관적 업데이트를 적용하면, 요청이 성공할 것이라고 가정하고 UI를 즉시 변경해 사용자에게 즉각적인 피드백을 제공할 수 있다.
        
        예를 들어,
        
        - ToDo 생성 시: 새 항목이 바로 목록에 추가되고, 서버 응답이 도착하면 실제 데이터로 교체된다.
        - 좋아요 토글 시: 버튼 클릭 즉시 좋아요 수가 변해 사용자는 반응이 즉각적이라고 느낀다.
        
        이 패턴은 특히 인터랙션이 많은 SNS나 커뮤니티 서비스, 모바일 네트워크 환경이 불안정한 앱 등에서 사용자 만족도를 크게 높인다.
        
        즉, 낙관적 업데이트는 “성공 가능성이 높은 작업에서 지연 없는 반응을 보장해주는 UX 최적화 기법”이다.
        
    - TanStack Query 기반 구현 흐름을 `onMutate → (mutate) → onError → onSettled` 순서로 기술해주세요..
        
        ### 1. onMutate — 변경 직전, UI를 먼저 업데이트하는 단계
        
        `mutate()`가 호출되면 가장 먼저 `onMutate`가 실행된다.
        
        이 시점에서 우리는 기존 데이터를 가져와 context에 저장해 두고,
        
        `queryClient.setQueryData`를 이용해 UI를 즉시 업데이트한다.
        
        즉, 서버 응답을 기다리지 않고 “요청이 성공할 것”이라고 가정해 화면을 먼저 바꾸는 것이다.
        
        이 단계는 낙관적 업데이트의 핵심이며, 이후 실패 시 복원할 수 있도록 이전 상태를 저장해 둔다.
        
        ### 2. mutate (mutationFn) — 실제 서버 요청이 이루어지는 단계
        
        `mutationFn`에서 POST, PUT, DELETE 등 비동기 요청이 수행된다.
        
        UI는 이미 바뀐 상태이지만, 이 시점에서 서버와의 실제 동기화가 진행된다.
        
        성공하면 `onSuccess`나 `onSettled`로 흐름이 이어지고, 실패하면 `onError`로 넘어간다.
        
        ### 3. onError — 요청 실패 시 롤백 단계
        
        서버 요청이 실패하면 `onError`가 실행된다.
        
        여기서는 `onMutate`에서 저장해 두었던 **이전 데이터(context)**를 꺼내와
        
        `queryClient.setQueryData`로 복원한다.
        
        즉, 실패한 변경 내용을 되돌려 데이터 일관성과 사용자 경험을 보호한다.
        
        이와 함께 사용자에게 에러 메시지를 표시할 수도 있다.
        
        ### 4. onSettled — 성공이든 실패든 마지막 정리 단계
        
        요청이 성공하거나 실패하더라도, `onSettled`는 항상 실행된다.
        
        이 단계에서 `queryClient.invalidateQueries`를 호출해
        
        관련 쿼리(예: `['todos']`, `['post', id]`)를 무효화하고,
        
        서버에서 최신 데이터를 다시 가져와 최종적으로 클라이언트와 서버 상태를 동기화한다.
        
    - ToDo “생성” 및 “좋아요 토글”에 **낙관적 업데이트(OptimisticUpdate)**를 적용했을 때의 **실패/충돌 롤백 전략**을 설계해주세요.
        
        ### ToDo 생성 시
        
        - onMutate
            - 기존 목록 데이터를 가져와 `context`에 저장.
            - 새 ToDo를 임시로 목록 상단에 추가 (`setQueryData`).
        - onError
            - 요청 실패 시 `context.previousTodos`로 롤백.
            - 사용자에게 “할 일을 추가하지 못했습니다.” 메시지 표시.
        - onSettled
            - 쿼리를 무효화(`invalidateQueries(['todos'])`)하여 서버와 최종 동기화.
        - 핵심 전략: “임시 추가 → 실패 시 삭제 → 성공 시 서버 데이터로 덮어쓰기”
        
        ### 좋아요 토글 시
        
        - onMutate
            - 기존 게시글 데이터를 복사해 `context`에 저장.
            - 클릭 즉시 `liked` 상태를 반전시키고, `likeCount`를 +1/-1로 변경.
        - onError
            - 요청 실패 시 저장된 이전 데이터를 복원.
            - 사용자에게 “좋아요 변경에 실패했습니다.” 알림 표시.
        - onSettled
            - 해당 게시글의 쿼리 키(`['post', postId]`)를 무효화해 서버 데이터 재동기화.
        - 핵심 전략: “UI 즉시 반영 → 실패 시 원래 상태로 복구 → 항상 최신 서버 상태와 일치 유지”